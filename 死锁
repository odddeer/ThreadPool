// 定义线程函数
void ThreadPool::threadFunc(int threadid)
{
    auto lastTime = std::chrono::high_resolution_clock().now();//上一次本线程执行完的时间

    while(isPoolRunning_) // 每个线程函数都在不停的要任务来做
    {
        std::shared_ptr<Task> task;//多态的父类
        {
            //先获取锁
            std::unique_lock<std::mutex> lock(taskQueMtx_);
            std::cout<<"tid"<<std::this_thread::get_id()
            <<"尝试获取任务..."<<std::endl;

            // cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s,应该把多余的线程结束回收掉
            // 超过initThreadSize_数量的线程要进行回收
            // 当前时间 - 上一次线程执行的时间 > 60s
            while(taskQue_.size()==0)// 任务队列没任务，看看是否自己多余了
            {
                if(poolMode_ == PoolMode::MODE_CACHED)//cached情况
                {// 每一秒钟返回一次， 怎么区分：超时返回？还是有任务待执行返回
                        // 条件变量，超时返回了
                        if(std::cv_status::timeout ==
                           notEmpty_.wait_for(lock,std::chrono::seconds(1)))
                        { // 超过1s没有拿到任务，被已经有的线程拿了，说明本线程可能多余了，看加上本线程是否超过起始线程，如果多说明本线程闲
                            auto now = std::chrono::high_resolution_clock().now();
                            auto dur = std::chrono::duration_cast<std::chrono::seconds>(now - lastTime);
                            if(dur.count()>=THREAD_MAX_IDLE_TIME
                               && curThreadSize_ > initThreadSize_)//闲了60s且不再起始线程数中
                            {
                                // 开始回收当前线程
                                // 记录线程数量的相关变量的值修改
                                // 把线程对象从线程列表容器中删除 没办法 threadFunc 中找到对应vector的哪一个线程位置-》改用map,创建线程号为key方便查找
                                // threadid => thread对象 => 删除
                                threads_.erase(threadid); // 清空线程vector中的对象
                                curThreadSize_--;//现有线程-1
                                idleThreadSize_--;//空闲线程-1

                                std::cout<<"threadid:"<<std::this_thread::get_id()<<" exit!"
                                         << std::endl;
                                return;
                            }
                        }
                    }
                else//fix情况
                {
                    //等待notEmpty条件
                    notEmpty_.wait(lock);//线程队列等不到就一直等任务
                }
                // 线程池要结束，回收线程资源
                if(!isPoolRunning_)//看唤醒两种情况的是不是要结束主线程的析构
                {
                    // 回收当前线程
                    threads_.erase(threadid); // 清空线程vector中的对象
                    std::cout<<"threadid:"<<std::this_thread::get_id()<<" exit!"
                             << std::endl;
                    std::cout<<threads_.size()<<"*"<<std::endl;
                    exitCond_.notify_all();//唤醒主线程pool的析构wait,看是否全走完
                    return;
                }
            }


            idleThreadSize_--;//任务队列有任务，则本线程会处理下面弄到的任务，本线程不再闲，闲数-1
            std::cout<<"tid"<<std::this_thread::get_id()
                     <<"获取任务成功..."<<std::endl;

            // 从任务队列取一个任务出来
            task = taskQue_.front();//子类给父类
            taskQue_.pop();//拿走任务
            taskSize_--;

            // 如果依然有剩余任务，继续通知其它的线程执行任务
            if(taskQue_.size() > 0)
            {
                notEmpty_.notify_all();
            }

            // 取出一个任务，进行通知，通知submitTask可以继续提交生产任务
            notFull_.notify_all();
        }//把锁释放掉，自己执行拿到的任务即可，无需拿着任务队列的锁

        // 当前线程负责执行这个任务
        if(task != nullptr)
        {
            //task->run(); 这只是执行任务，现在把任务结果返回
            task->exec();
        }
        idleThreadSize_++;//本线程处理完取的任务再次闲下来，闲+1
        lastTime = std::chrono::high_resolution_clock().now();// 更新线程执行完任务的时间，本线程开始空闲
    }
    // 析构结束时，在执行的本线程回到循环while发现要析构了，跳出循环到这，开始析构本线程
    threads_.erase(threadid); // 清空线程vector中的对象
    std::cout<<"threadid:"<<std::this_thread::get_id()<<" exit!"
             << std::endl;
    std::cout<<threads_.size()<<std::endl;
    exitCond_.notify_all();//唤醒主线程pool的析构wait,看是否全走完
}

ThreadPool::~ThreadPool()
{   // pool对象到}后执行该析构函数
    isPoolRunning_ = false;
    notEmpty_.notify_all();//把所有等任务的线程唤醒，开始抢锁-》发现线程池要结束的信息，开始自行析构各种线程
    // 等待线程池里面所有的线程返回 有两种状态：阻塞 & 正在执行任务中
    std::unique_lock<std::mutex> lock(taskQueMtx_);
    exitCond_.wait(lock,[&]()->bool {return threads_.size() == 0;});//等其他线程都清空（睡着+等唤醒）

}